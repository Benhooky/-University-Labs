/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/


#define	  stop __asm nop
#define _CRT_SECURE_NO_WARNINGS
#include <vld.h>
#include<iostream>
#include<cstdlib>
#include<ctime>
#include<string>
#include<cstring>
int main()
{


	///////////////////////////////////////////////////////////////
	//			Встроенные массивы                               //
	///////////////////////////////////////////////////////////////

		//Задание 1. Объявите трехмерный N*M*K массив и сформируйте указанные
		//значения элементов следующим образом:
		//а) проинициализируйте массив при объявлении

	int Arr[3][3][3] = { {1,1,1,1,1,1,1,1,1},{2,2,2,2,2,2,2,2,2},{3,3,3,3,3,3,3,3,3} };
  	int l, i;
	{
		int* w = &Arr[0][0][0];
		for (i = 26; i > 0; i--)
		{
			std::cout << *w;
			w++;
		}
		std::cout << std::endl;

	}
	//б)* объявите неинициализированный массив и присвойте значения элементам
	//	с помощью кода
	//					 |--------|
	//				   / |3  3  3 |
	//    			 |---------|3 |
	//			   / | 2  2  2 |3 |
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__|
	//			  | 1  1  1 | /
	//			  |_________|
	//Средствами отладчика проверьте правильность Вашего решения.
	{
		int Arrc[3][3][3], f = 0;
		int* q = &Arrc[0][0][0];

		while (f < 8)
		{
			f++;
			*q = 1;
			q++;
		}
		while (f < 17)
		{
			{
				f++;
				*q = 2;
				q++;
			}
		}
		while (f < 26)
		{
			{
				f++;
				*q = 3;
				q++;
			}
		}
		l = Arrc[2][0][0];
		int* w = &Arr[0][0][0];
		for (i = 26; i > 0; i--)
		{
			std::cout << *w;
			w++;
		}
		std::cout << std::endl;



		//в) найдите сумму элементов массива
		{
			int sum = 0;
			int* r = &Arr[0][0][0];
			for (int i = sizeof(Arr) / sizeof(int); i > 0; i--)
			{
				sum += *r;
				r++;
			}

			std::cout << sum << std::endl;
		}


		//г) проинициализируйте массив при определении:
		//					 |--------|
		//				   / |3  0  0 |
		//    			 |---------|0 |
		//			   / | 2  0  0 |0 |
		//			  |---------|0 |__|
		//			  | 1  0  0 |0 | /
		//			  | 0  0  0 |__|
		//			  | 0  0  0 | /
		//			  |_________|

		{
			int Arr[3][3][3] = { {1,0,0,0,0,0,0,0,0},{2,0,0,0,0,0,0,0,0},{3,0,0,0,0,0,0,0,0} };
			int* w = &Arr[0][0][0];
			for (i = 26; i > 0; i--)
			{
				std::cout << *w;
				w++;
			}
			std::cout << std::endl;
		}

		//д)* Инициализация массивов строковыми литералами:
		//Объявите и проинициализируйте строковыми литералами два массива:
		//двухмерный массив и массив указателей. Поясните разницу в использовании
		//элементов таких массивов.
		{
			char varp[3][80] = { {"asfahfreq"},{"gsda"},{"safwq"} };
		}
		{
			const char* varp[] = { "obe","rqwt","eqs" };
		}



		///////////////////////////////////////////////////////////////
		//			Динамическое выделение памяти                    //
		///////////////////////////////////////////////////////////////
			//Задание2. Создайте динамический двухмерный массив с размерностями,
			//вычисляемыми в процессе выполнения программы - N*M.
			//Задайте значения элементов помощью генератора случайных чисел.
			//Найдите  сумму элементов.
			//Подсказка 1: для генерации случайных чисел используйте функцию
			//стандартной библиотеки - rand() (<cstdlib>)
			//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
			//чисел являются «псевдослучайными», то есть при двух последовательных запусках
			//приложения Вы получаете две одинаковые последовательности значений.
			//Для того чтобы генерируемые "случайные" значения были разными при каждом
			//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
			//и time() (<ctime>).
			//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
			//Функция time() задает эту точку отсчета, считывая текущее время

			//srand( time( 0 ) );

		{
			int N, M, sum = 0, z;
			srand(time(0));
			N = 3;
			M = 3;
			int** p = new int* [N];
			for (int i = 0; i < N; i++)
			{
				p[i] = new int[M];
			}
			for (int i = 0; i < N; i++)
			{
				for (int j = 0; j < M; j++)
				{
					p[i][j] = rand();
				}
			}
			for (int i = 0; i < N; i++)
			{
				for (int j = 0; j < M; j++)
				{
					std::cout << p[i][j] << ' ';
					sum += p[i][j];
				}
			}
			std::cout << sum << std::endl;
			for (int i = 0; i < N; i++)// ЗАДАНИЕ 2А
			{
				for (int j = 0; j < M; j++)
				{
					z = p[i][j];
					static int l;
					for (int rj = j + 1; rj < M; rj++)
					{
						if (p[i][rj] > z)
						{
							l = p[i][rj];
							p[i][rj] = z;
							p[i][j] = l;
						}
					}


				}
			}
			for (int i = 0; i < N; i++)
			{
				for (int j = 0; j < M; j++)
				{
					std::cout << p[i][j] << ' ';
				}
			}
			{
				int* np = new int[N];//ЗАДАНИЕ 2Б
				int i, v = 0;
				std::cin >> i;
				for (int vp = 0; vp < N; vp++)
				{
					np[vp] = 0;
				}
				for (int k = 0; k < M; k++)
				{
					v += p[i][k];
				}
				np[i] = v / M;
				for (int pc = 0; pc < N; pc++)
				{
					std::cout << np[pc] << ' ';
				}
				std::cout << std::endl;
				delete[]np;
			}
			for (int i = 0; i < N; i++)
			{
				for (int j = 0; j < M; j++)
				{
					std::cout << p[i][j] << ' ';
				}
			}
			for (i = 0; i < N; i++)
			{
				delete[]p[i];
			}
			delete[]p;
		}

		//Задание2а. В сформированном массиве отсортируйте каждую строку по
		//убыванию значений. Используйте сортировку "выбором"


		//Задание2б. Объявите одномерный массив размерностью N.
		//Сформируйте значение i-ого элемента одномерного массива
		//равным среднему значению элементов i-ой строки
		//двухмерного массива


		//Подсказка - не забудьте освободить память!





		/////////////////////////////////////////////////////////////////////
		//Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
		//потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
		//упорядочивая полученное значение по возрастанию
		//Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
		//потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
		//упорядочивая полученное значение по возрастанию

		{
			int N = 4, l, k, v = 0, c, n = 1;
			int M[4];
			int L[4];
			std::cout << "Введите значения элементов массива";
			for (i = 0; i < N;)
			{
				std::cin >> c;
				L[i] = c;
				for (int b = 0; b < i; b++)
				{
					if (L[b] == c)
					{
						n = 0;
						i--;
					}
				}
				if (n)
				{
					M[i] = c;
					v = 1;
					for (k = 0; k < N; k++)
					{
						while ((M[i - v] > c) && (i > 0))
						{
							l = M[i - v];
							M[i - v] = c;
							M[i - v + 1] = l;
							v++;
						}
					}
				}
				n = 1;
				i++;
			}
			for (i = 0; i < N; i++)
			{
				std::cout << M[i];
			}
			std::cout << std::endl;
		}



		//б) Простой поиск.
		//Модифицируйте предыдущее задание следующим образом:очередное значение
		//вводится в массив только при условии, что там еще такого нет (то есть
		//дубли игнорируются




		///////////////////////////////////////////////////////////////////////////
		//Задание 4*.С помощью данной заготовки напишите программу,
		//которая:
		//вводит строки с клавиатуры с помощью cin>>...
		//в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
		//признаком конца ввода является символ * (то есть строка - "*") или
		//заполнение массива (больше свободных строк нет);
		//сортировка строк в алфавитном порядке. Пояснение: крайне
		//не рекомендуется для сортировки сложных объектов физически
		//перемещать их в памяти. Намного эффективнее завести массив
		//указателей на соответствующие строки и перемещать только
		//указатели.

		//Подсказка: для лексиграфического сравнения строк пользуйтесь
		//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.


		//Определите необходимые значения как константы
#define STOP_STRING "*"	//признак "прекратить ввод"
		{
			const int M = 80;	//максимальный размер одной строки
			const int N = 10;	//максимальное количество строк в массиве



			//Объявите двухмерный массив с именем cBuffer типа char и
			// размерностью N*M
      char cBuffer[N][M] = { 0 };

			//Объявите массив (с именем cPointers) указателей на строки
			//размерностью N
			char* cPointers[N] = { 0 };

			//Цикл ввода строк:
			//а) выведите приглашение для ввода

			//б) пока не введена строка STOP_STRING или не заполнен весь массив
			char* p = &cBuffer[0][0];
			int sum = 0;
			char string[80];
			for (int i = 0; i < N; i++)
			{
				std::cin >> string;
				if (strcmp(string, STOP_STRING) == 0)
					break;
				strcpy(cBuffer[i], string);
			}
			for (int m = 0; m < N; m++)
			{
				for (int j = 0; j < M; j++)
				{
					std::cout << cBuffer[m][j];
				}
			}
			std::cout << std::endl;
			for (int i = 0; i < N; i++)
			{
				//ввод строки в массив cBuffer:

				//если введена строка - признак окончания, то выйти из цикла

				//Присвойте элементу массива cPointers с индексом nIndex
				//указатель на строку с номером nIndex в массиве cBuffer
				cPointers[i] = &cBuffer[i][0];

			}



			//Выдать диагностику о том, что прием строк завершен.



			//Теперь сортируем строки:

			//Цикл сортировки строк по методу "всплывающего пузырька" в
			//порядке возрастания. На каждой итерации - промежуточная печать
			//отсортированных строк
			char* sd = 0;
			for (int c = 0; c < N; c++)
			{
				for (int i = 0; i < N - 1; i++)
				{
					if (*cPointers[i] > * cPointers[i + 1])
					{
						sd = cPointers[i];
						cPointers[i] = cPointers[i + 1];
						cPointers[i + 1] = sd;
					}

				}
			}
			for (int m = 0; m < N; m++)
			{
				std::cout << cPointers[m] << std::endl;
			}

			std::cout << std::endl;

		}


		//Задание 5*. Реализуйте задание №4, используя не встроенные,
		//а динамические массивы (массив?). Так как строки могут быть разной длины,
		//эффективным решением было бы отводить под каждую строку ровно столько байтов,
		//сколько требуется для ее хранения.
		//При этом необходимые параметры (количество строк
		// сформируйте с помощью потока ввода
		{


			int nStringNumber;
  		std::cin >> nStringNumber;
		char** cBuffer = new char* [nStringNumber] {};
			for (int i =  0; i < nStringNumber; i++)
			{
				cBuffer[i] = new char[80]{};
			}
      char *war = &cBuffer[0][0];
			int L = 80;
			int sum = 80;
			char* stasfaasfring = new char[80];
			int i = 0;
			char* p;
			for (int i = 0; i < nStringNumber; i++)
			{
				p = &cBuffer[i][0];
				while (sum)
				{
          std::cin >> stasfaasfring;
          if (strcmp( stasfaasfring, STOP_STRING ) == 0) break;
          L = strlen( stasfaasfring );
					if (L > sum) break;
					for (int j = 0; j < L; j++)
					{
            *p = stasfaasfring[j];
						p++;
					}
					sum -= L;
				}
				sum = 80;
        if (strcmp( stasfaasfring, STOP_STRING ) == 0) break;
			}

      delete[] stasfaasfring;

			for (int c = 0; c < nStringNumber; c++)
			{
				for (int i = 0; i < nStringNumber - 1; i++)
				{
					if (*cBuffer[i] > * cBuffer[i + 1])
					{
						char* temp = cBuffer[i];
						cBuffer[i] = cBuffer[i + 1];
						cBuffer[i + 1] = temp;
					}

				}
			}
			for (int m = 0; m < nStringNumber; m++)
			{
				std::cout << cBuffer[m] << std::endl;
			}
			for (int i = 0; i < nStringNumber; i++)
			{
				delete[]cBuffer[i];
			}
			std::cout << std::endl;
			std::cout << std::endl;

			delete[]cBuffer;




			//Цикл ввода строк:




			//Цикл сортировки строк по методу "всплывающего пузырька" в
			//порядке возрастания кода первого символа





			//Освобождение занятой памяти:







			//Задание 6*. Объявление и использование указателей на многомерные
			// массивы. Проинициализируйте трехмерный массив
			//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
			//кода, который меняет местами значения элементов четных
			//и нечетных слоев:
			//	было:			     |--------|		
			//  				   / |4  4  4 |		
			//					 |--------|	4 |	
			//				   / |3  3  3 |	4 |	
			//    			 |---------|3 |   |
			//			   / | 2  2  2 |3 | /
			//			  |---------|2 |__|
			//			  | 1  1  1 |2 | /
			//			  | 1  1  1 |__| 
			//			  | 1  1  1 | /
			//			  |_________|

			//	стало:			     |--------|		
			//  				   / |3  3  3 |		
			//					 |--------|	3 |	
			//				   / |4  4  4 |	3 |	
			//    			 |---------|4 |   |
			//			   / | 1  1  1 |4 | /
			//			  |---------|1 |__|
			//			  | 2  2  2 |1 | /
			//			  | 2  2  2 |__| 
			//			  | 2  2  2 | /
			//			  |_________|

			double dArray[4][3][3] = { {1,1,1,1,1,1,1,1,1},{2,2,2,2,2,2,2,2,2},{3,3,3,3,3,3,3,3,3},{4,4,4,4,4,4,4,4,4} };
			double(*pnn)[3];
			double(*pnc)[3];
			double* w = &dArray[0][0][0];
			for (int i = 0; i < 3; i++)
			{

				pnn = dArray[i];
				pnc = dArray[i + 1];
				double a = **pnn;
				double b = **pnc;
				for (int j = 0; j < 3; j++)
				{
					for (int z = 0; z < 3; z++)
					{
						dArray[i][j][z] = b;
					}
				}
				for (int j = 0; j < 3; j++)
				{
					for (int z = 0; z < 3; z++)
					{
						dArray[i + 1][j][z] = a;
					}
				}
				i++;

			}
			//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
		//переставляем местами элементы i-того и i+1-ого слоев
			for (int i = 36; i > 0; i--)
			{
				std::cout << *w;
				w++;
			}
			std::cout << std::endl;



			///////////////////////////////////////////////////////////////////////////
			//Задание 7а. Объявите двухмерный встроенный массив элементов типа char.
			//Сформируйте значения элементов массива с помощью генератора случайных
			//чисел таким образом, чтобы в массиве были только символы '*' и '_'


			//В каждой строке "сдвиньте звездочки" в начало строки, например:
			//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
			//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
			//и распечатайте массив по строкам - "постройте распределение"

			{
				char array[5][10];
				srand(time(0));
				int b = 0;
				for (int i = 0; i < 5; i++)
				{
					for (int j = 0; j < 10; j++)
					{
						bool a = rand() % 2;
						if (a == 0)
						{
							array[i][j] = '*';
						}
						else
						{
							array[i][j] = '_';
						}
					}
				}
				for (int i = 0; i < 5; i++)
				{
					for (int j = 0; j < 10; j++)
					{
						std::cout << array[i][j] << ' ';
					}
					std::cout << std::endl;
				}
				for (int i = 0; i < 5; i++)
				{
					for (int j = 0; j < 10; j++)
					{
						if (array[i][j] == '*')
						{
							b += 1;
						}
					}
					for (int r = 0; r < 10; r++)
					{
						array[i][r] = '_';
					}
					int v = 0;
					while (b)
					{
						array[i][v] = '*';
						b--;
						v++;
					}
				}
				for (int i = 0; i < 5; i++)
				{
					for (int j = 0; j < 10; j++)
					{
						std::cout << array[i][j] << ' ';
					}
					std::cout << std::endl;
				}
			}

			std::cout << std::endl;
			// 7б. Модифицируйте предыдущее задание следующим способом:
			//После заполнения массива с помощью генератора случайных чисел
			//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
			//"распределение"

			{
				char array[5][10];
				srand(time(0));
				int b = 0;
				for (int i = 0; i < 5; i++)
				{
					for (int j = 0; j < 10; j++)
					{
						bool a = rand() % 2;
						if (a == 0)
						{
							array[i][j] = '*';
						}
						else
						{
							array[i][j] = '_';
						}
					}
				}
				for (int i = 0; i < 5; i++)
				{
					for (int j = 0; j < 10; j++)
					{
						std::cout << array[i][j] << ' ';
					}
					std::cout << std::endl;
				}
				for (int i = 0; i < 10; i++)
				{
					for (int j = 0; j < 5; j++)
					{
						if (array[j][i] == '*')
						{
							b += 1;
						}
					}
					for (int r = 0; r < 5; r++)
					{
						array[r][i] = '_';
					}
					int v = 0;
					while (b)
					{
						array[4 - v][i] = '*';
						b--;
						v++;
					}
				}
				for (int i = 0; i < 5; i++)
				{
					for (int j = 0; j < 10; j++)
					{
						std::cout << array[i][j] << ' ';
					}
					std::cout << std::endl;
				}
			}
		}
	}
  return 0;
}



