#include "myRect.h"
#include "myString.h"
#include <iostream>
#include "vld.h"


Rect BoundingRect(Rect a, Rect b)
{
	Rect c;
	int left1, left2, right1, right2, top1, top2, bot1, bot2;
	a.Get(left1, right1, top1, bot1);
	b.Get(left2, right2, top2, bot2);
	int lenth1 = left1 + right1 + left2 + right2;
	int width1 = ((top1 + bot1) > (top2 + bot2) ? top1 + bot1 : top2 + bot2);
	c.SetAll((lenth1 + 1) / 2, (lenth1 + 1) / 2, (width1 + 1) / 2, (width1 + 1) / 2);
	return c;	
}
Rect BoundingRect2(Rect& a, Rect& b)
{
	Rect c;
	int left1, left2, right1, right2, top1, top2, bot1, bot2;
	a.Get(left1, right1, top1, bot1);
	b.Get(left2, right2, top2, bot2);
	int lenth1 = left1 + right1 + left2 + right2;
	int width1 = ((top1 + bot1) > (top2 + bot2) ? top1 + bot1 : top2 + bot2);
	c.SetAll((lenth1 + 1) / 2, (lenth1 + 1) / 2, (width1 + 1) / 2, (width1 + 1) / 2);
	return c;
}

bool operator== (const A& c1, const A& c2)
{
	int q = 0;
	if (c1.m_n == c2.m_n)
	{
		for (int i = 0; i < c1.m_n; i++)
		{
			if (c1.m_p[i] == c2.m_p[i])
			{
				q++;
			}
		}
		if (q == c1.m_n)
		{
			return true;
		}

	}
}
Point operator--(Point& a)
{
	a.x--;
	a.y--;
	return(a);
}
Point operator--(Point& a, int)
{
	Point b(a);
	--a;
	return b;
}
template <typename T>
void Swap(T a, T b)
{
	T ab;
	ab = a;
	a = b;
	b = ab;
}
template <typename T>
void Swap(const T& a,const T& b)
{
	T ab;
	ab = a;
	a = b;
	b = ab;
}
template <typename T>
void Min(const T& a, const T& b)
{
	return (strcmp(a, b) < 0) ? a : b;
}
template <typename T>
void Min( T a,  T b)
{
	return (a<b) ? a : b;
}
int main()
{
	using namespace std;

	//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса?

	{
		MyArray<int, 5> arr; //создать массив размерностью 5 типа int
		MyArray<Rect, 6> arr2;

		std::cout << arr[2] << std::endl;
	}
	{
		Rect rect;
	}
	{
		Point pt1(1, 1), pt2, pt3;
		pt2 = pt1--;

		pt2 = --pt1;
	}
	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?
	{


		Rect f(-100000, 20, 30, 40);


		//Подсказка: учтите, что пользователь Вашего класса может указывать
		//в качестве параметров любые значения!


		//1б. При конструировании объекта посредством конструктора без параметров
		//предусмотрите инициализацию переменных класса, например, нулем

		Rect sq;

		//1в. Объявите, определите и вызовите метод класса InflateRect(), 
		//который увеличивает размеры прямоугольника на заданные приращения
		//(раздвигая стороны от центра - каждую сторону на свое значение).
		//Подсказка: объявить и определить методы можно не только "вручную",
		//но и с помощью Wizard-a Class View. Для этого: откройте закладку
		//ClassView окна проекта, сделайте активным класс Rect и нажмите
		//правую кнопку мыши - в появившемся контекстном меню выберите
		//Add/Add Member Function... С помощью появившейся диалоговой панели
		//"дайте указания" Wizard-у как объявить и определить метод.

		sq.InflateRect(2, 4, 6, 8);
	}
	//Задание 2.Перегрузка конструкторов и методов класса.
	//Конструктор копирования.
	{
		//2а.Объявите и определите конструктор копирования в классе Rect.
		//Выполняя задание по шагам, определите, какой
		//конструктор вызывается при создании r1,r2,r3 и r4?
		//Чему равны переменные созданных объектов?
		Rect r1;
		Rect r2(1, 2, 3, 4);
		Rect r3;
		r3= r1;
		Rect r4(r2);



		//2б. Объявите и определите в классе Rect метод InflateRect(),
		  //который принимает два аргумента, по умолчанию равных 1, и 
		  //раздвигает стороны прямоугольника на на заданные приращения.
		  //Для каких объектов вызывается функция InflateRect()?
		r1.InflateRect(1, 1);
		r2.InflateRect(2, 2);
		//Какая из функций InflateRect() вызывается в каждом из трех случаев?
		r3.InflateRect(2, 2, 2, 2);
		r3.InflateRect(3, 3);
		r3.InflateRect(5);
		r3.InflateRect();


	}

	//Задание 3.Спецификаторы доступа. Инкапсуляция. 
	{
	Rect r;
	//Раскомментируйте следующую строку. Объясните ошибку
	//компилятора

	//int tmp = r.m_left;  по умолчанию переменные находятся в private для выполнения принципа инкапсуляции



	//Введите в класс Rect метод void SetAll(...),
	//который присваивают переменным класса передаваемые
	//значения. Вызовите созданный метод, проверьте корректность. 
	r.SetAll(5, -5, 125, 625);

	//Введите в класс Rect парный метод GetAll(...),
	//который "достает" значения private-переменных класса.
	//Вызовите созданный метод, проверьте корректность. 
	int inf[4];
	r.GetAll(inf);

	for (int i = 0; i < 4; i++)
	{
		cout << inf[i] << ' ';
	}
	
	}


	//Задание 4.Передача экземпляра класса в качестве параметра
	//функции. Возвращение объекта класса по значению. Поставив
	//остановы в конструкторе копирования или выполняя фрагмент
	//по шагам, определите: в какой момент происходит обращение
	//к конструктору копирования. 
	//Создайте глобальную функцию 
	// Rect BoundingRect(Rect, Rect);
	//которая принимает два объекта класса Rect по значению и
	//возвращает объект класса Rect, который является прямоугольником,
	//в который вписаны заданные прямоугольники. Как происходит
	//передача параметров и возвращение объекта класса?


	//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
	//может оказаться "ненормализованным", то есть m_left>m_right или/и
	//m_top>m_bottom

	{

		Rect r1(1,2,3,4), r2(5,6,7,8),r3;
		r3= BoundingRect(r1, r2);
	
	
	//Задание 4а. Передача объектов по ссылке.
	//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
	//задачу, принимая параметры по ссылке
	//Вызываются ли конструкторы при передаче параметров?
	

	r3 = BoundingRect2(r1, r2);
	
	}

	


	//Задание 5. Когда вызываются конструкторы и деструкторы.
	//Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
		Rect r1;
		Rect*	pR = new Rect(1,2,1,2);	
		{
			Rect r2(r1);
			Rect* arRect[2];  // 2 default
			for(int i=0; i<2; i++)
			{
				 Rect r3 (i,i,i,i) ;
				 static Rect r4(*pR);  // на второй ит. copy
				Rect r5(i,i,i,i);
			}
		}
		delete pR;	
		
	}


	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
	{
		MyString	str("It's my string!"),str22;
		MyString str33(str22);
		str33 = str;
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str
		//Замечание: подумайте, как следует корректно реализовать метод GetString().
		const char* string=str.GetString();
		while (*string != 0)
		{
			cout << *string;
			string++;
		}
		//...
	}
	


		//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
		//неприятности Вас ожидают. Попробуйте исправить положение (как?)
	{
		MyString str1("The first string!");//дважды удаляется одна и та же ячейка памяти т.к копируется указатель 
			MyString str2=str1;
			
	}
		

	//6б. Реализуйте метод SetNewString, который будет заменять строку
	// на новую

	
	{

	MyString	str("It's");
	char q[] = "ha";
	str.SetNewString(q);
	}
		
	
	




	//Задание 7.  Решите с помощью классов следующую задачу:
	//даны две бочки известного объема. В одной бочке в начальный момент
	//времени содержится спирт (96%), в другой – вода.
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
	//в другую следующим способом: на каждой итерации
	//зачерпнули из первой бочки -> вылили во вторую
	//зачерпнули из второй бочки -> вылили в первую.
	//Требуется определить номер итерации, на которой концентрация спирта в
	//первой бочке станет меньше 50%.

	Bochka first(96);
	Bochka second(0);
	Bochka check(50);
	double a, b;
	int counter = 0;
	//]одна бочка 100 литров
	
	while(first.get(a)>check.get(b))
	{
		counter++;
			first.Pereliv(second); //или spirt.Pereliv(water, объем_кружки);
			second.Pereliv(first); // аналогично
	    }
	cout << endl << counter<<endl;
return 0;

}//end_main

